#pragma once
#include <unordered_map>
#include <string>
#include <cstring>
#include <iostream>
#include <vector>
#include <algorithm>
//only for this file, so things don't crash for 32-bit systems
#define size_t uint32_t

namespace Serialize{

  bool is_big_endian(void){
    union {
      uint32_t i;
      char c[4];
    } e = { 0x01000000 };
    return e.c[0];
  }

  void* invert_endian_h(uint16_t element_size, size_t element_count, void* data_reg){
    char* data_invert = (char*)malloc(element_size * element_count);
    char* data = (char*)data_reg;
    for(size_t i = 0; i < element_count * element_size; i += element_size){
      for(uint16_t e = 0; e < element_size; e++){
        data_invert[i + e] = data[i + (element_size - 1) - e];
      }
    }
    return data_invert;
  }

  template<typename T>
  T little_endian(T d){
    if(!is_big_endian()) return d;
    T d_copp = d;
    T* d_corr = (T*)invert_endian_h(sizeof(T), 1, &d_copp);
    d_copp = *d_corr;
    free(d_corr);
    return d_copp;
  }

  class SizedBlock{
  public:
    void* contents_native;
    uint16_t element_span;
    size_t span = 0;
    
    SizedBlock(uint16_t element_size, size_t element_count, void* data){
      contents_native = malloc(element_size * element_count);
      span = element_count * element_size;
      element_span = element_size;
      memcpy(contents_native, data, element_size * element_count);
    }

    SizedBlock(){};

    std::vector<char> lower(){
      if(!span){
        return std::vector<char>();
      }
    }

    void dump(){
      if(!span) return;
      free(contents_native);
      span = 0;
      element_span = 0;
    }

    ~SizedBlock(){
      dump();
    }

  };

}

#undef size_t

